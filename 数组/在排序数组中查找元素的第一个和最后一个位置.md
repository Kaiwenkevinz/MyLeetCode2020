### 暴力查找 O(n) 21.38%
```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int s = 0;
        int e = nums.length - 1;
        while (s < nums.length) {
            if (nums[s] == target) {
                break;
            }
            s++;
        }
        while (e >= 0) {
            if (nums[e] == target) {
                break;
            }
            e--;
        }
        if (e == -1) {
            return new int[] {-1, -1};
        } else {
            return new int[] {s, e};
        }
    }
}
```

### 二分 100.00%
二分的时候要特别注意下面的情况：
```java
while (l <= r) {
  ...
  else {
    l = m;   // 当 l + 1 = r 时，m 永远是 l, l不会移动，导致死循环
  }
  ...
}
```
```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if (nums.length == 0) {
            return new int[] {-1, -1};
        }

        int l = 0;
        int r = nums.length - 1;
        int s = -1;
        int e = -1;
        while (l < r) {
            int m = l + ((r - l) >> 1);
            if (nums[m] > target) {
                r = m - 1;
            } else if (nums[m] < target) {
                l = m + 1;
            } else {
                r = m;
            }
        }
        if (nums[l] == target) {
            s = l;
        } else {
            return new int[] {-1, -1};
        }

        l = 0;
        r = nums.length - 1;
        while (l < r) {
            int m = l + ((r - l) >> 1);
            if (nums[m] > target) {
                r = m - 1;
            } else if (nums[m] < target) {
                l = m + 1;
            } else {
                l = m;
                if (l < nums.length - 1 && nums[l + 1] == target) {  // l不是最后一个，nums[l + 1] 是新的右边界
                    l = m + 1;
                } else {  // 要么 l 是最右元素，要么 nums[l + 1] 不是target，这两种情况都说明找到了右边界
                    break;
                }
            }
        }
        e = l;
        return new int[] {s, e};
    }
}
```
